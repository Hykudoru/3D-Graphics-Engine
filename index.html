<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.js"></script>-->
    <script src="jquery-3.6.4.min.js"></script>
    <script src="p5.min.js"></script>
    <title>3D Graphics</title>
    <style>
        body {
            background-color: #1b1a1a;
            color: rgb(213, 212, 212);
            text-align: center;
            margin: auto;
            padding: auto;
        }

        h1 {
            text-align: center;
            padding: 20px;
        }

        canvas {
            /* min-width: 340px;*/
            /* min-height: 340px;*/
            /*max-width: 640px;*/
            /*max-height: 640px;*/
        }
    </style>
</head>

<body>
    <h1 id="title">3D Graphics Engine</h1>
    <script src="sketch.js"></script>
</body>
<script>
    //-----------GRAPHICS---------------
    // Returns a Rotation Matrix about the X axis (in radians)
    // | 1,   0,      0     |
    // | 0, Cos(T), -Sin(T) |
    // | 0, Sin(T),  Cos(T) |
    function RotX(theta) {
        Cos = cos(theta);
        Sin = sin(theta);

        let matrix = [
            [1, 0, 0],
            [0, Cos, -Sin],
            [0, Sin, Cos]
        ];

        return matrix;
    }

    // Returns a Rotation Matrix about the Y axis (in radians)
    // | Cos(T),  0,   Sin(T)  |
    // |   0,     1,     0     |
    // |-Sin(T),  0,   Cos(T)  |
    function RotY(theta) {
        Cos = cos(theta);
        Sin = sin(theta);

        let matrix = [
            [Cos, 0, Sin],
            [0, 1, 0],
            [-Sin, 0, Cos]
        ];

        return matrix;
    }

    // Returns a Rotation Matrix about the Z axis (in radians)
    // | Cos(T), -Sin(T), 0 |
    // | Sin(T),  Cos(T), 0 |
    // |   0,      0,     1 |
    function RotZ(theta) {
        let Cos = cos(theta);
        let Sin = sin(theta);

        let matrix = [
            [Cos, -Sin, 0],
            [Sin, Cos, 0],
            [0, 0, 1]
        ];

        return matrix;
    }

    function VectorScale(vector, scaler) {
        let vec = {};
        vec.x = vector.x * scaler;
        vec.y = vector.y * scaler;
        vec.z = vector.z * scaler;

        return vec;
    }

    function VectorSum(vec1, vec2) {
        let vectorSum = { x: (vec1.x + vec2.x), y: (vec1.y + vec2.y), z: (vec1.z + vec2.z) };
        return vectorSum;
    }

    function DotProduct(vecA, vecB) {
        return (vecA.x * vecB.x) + (vecA.y * vecB.y) + (vecA.z * vecB.z);
    }

    function MatrixMultiply(matrixA, matrixB) {
        let result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        for (var r = 0; r < 3; r++) {
            let rowVec = { x: matrixA[r][0], y: matrixA[r][1], z: matrixA[r][2] };
            for (var c = 0; c < 3; c++) {
                let columnVec = { x: matrixB[0][c], y: matrixB[1][c], z: matrixB[2][c] };
                result[r][c] = DotProduct(rowVec, columnVec);
            }
        }

        return result;
    }

    function MatrixVectorMultiply(matrix, columnVector) {
        result = [0, 0, 0];
        for (var r = 0; r < 3; r++) {
            let rowVec = { x: matrix[r][0], y: matrix[r][1], z: matrix[r][2] };
            result[r] = DotProduct(rowVec, columnVector);
        }

        return { x: result[0], y: result[1], z: result[2] };
    }


    // Yaw-Pitch-Roll z-y'-x''(intrinsic rotation) or x-y-z (extrinsic rotation)
    function YPR(roll, pitch, yaw) {
        let rotationMatrix = MatrixMultiply(MatrixMultiply(RotZ(yaw), RotY(pitch)), RotX(roll));//MatrixMultiply(rotation.matrix, RotZ(PI/2.0).matrix);
        return rotationMatrix;
    }

    function Matrix4x4Multiply(matrix4x4, columnMatrix) {
        let mtx = new Matrix4x4();
        for (var r = 0; r < 4; r++) {
            let rowVec = new Vec4(matrix4x4[r][0], matrix4x4[r][1], matrix4x4[r][2], matrix4x4[r][3]);
            for (var c = 0; c < 4; c++) {
                let columnVec = new Vec4(columnMatrix[0][c], columnMatrix[1][c], columnMatrix[2][c], columnMatrix[3][c]);
                mtx.matrix[r][c] = DotProduct(rowVec, columnVec);
            }
        }

        return mtx.matrix;
    }

    function Matrix4x4VectorMult(matrix4x4, vec4) {
        result = [];
        for (var r = 0; r < 3; r++) {
            let rowVec = new Vec4(this.matrix[r][0], this.matrix[r][1], this.matrix[r][2], this.matrix[r][3]);
            result[r] = DotProduct(rowVec, columnVector);
        }

        return new Vec4(result[0], result[1], result[2], result[3]);
    }

    class Matrix3x3 {
        matrix = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];
    }
    
    class Matrix4x4 {
        matrix = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ];
    }

    class Vec3 {
        v = [0, 0, 0];
        get x() { return this.v[0];} set x(val) {this.v[0] = val;}
        get y() { return this.v[1];} set y(val) {this.v[1] = val;}
        get z() { return this.v[2];} set z(val) {this.v[2] = val;}

        constructor(x = 0, y = 0, z = 0) {
            this.v[0] = x;
            this.v[1] = y;
            this.v[2] = z;
        }
    }

    class Vec4 extends Vec3 {
        get w() { return this.vector[3]} set w(val) {this.vector[3] = val;}

        constructor(x = 0, y = 0, z = 0, w = 1) {
            super(x, y, z);
            this.v[3] = w;
        }
    }

    



    let imu = {
        rotX: 0,
        rotY: 0,
        rotZ: 0,

        i: { x: 0, y: 0, z: -1 },
        j: { x: 1, y: 0, z: 0 },
        k: { x: 0, y: 1, z: 0 },

        posX: 0,
        posY: 0,
        posZ: 0
    };

    var forward = { x: 0, y: 0, z: -1 };
    var back = { x: 0, y: 0, z: 1 };
    var right = { x: 1, y: 0, z: 0 };
    var left = { x: -1, y: 0, z: 0 };
    var up = { x: 0, y: -1, z: 0 };
    var down = { x: 0, y: 1, z: 0 };

    var orthographicProjectionMatrix = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 0]
    ]

    class CubeMesh {
        scale = 1;//= {x:1,y:1,z:1};
        position = { x: 0, y: 0, z: 0 };
        
        vertices = [
            { x: -1, y: 1, z: 1 },
            { x: -1, y: -1, z: 1 },
            { x: 1, y: -1, z: 1 },
            { x: 1, y: 1, z: 1 },
            //forward
            { x: -1, y: 1, z: -1 },
            { x: -1, y: -1, z: -1 },
            { x: 1, y: -1, z: -1 },
            { x: 1, y: 1, z: -1 }
        ];

        projVertices = [];

        scaleMatrix = [
            [this.scale.x,  0,          0,          0],
            [   0,     this.scale.y,    0,          0],
            [   0,          0,      this.scale.z,   0],
            [   0,          0,          0,          1],
        ]
        
        rotationMatrix = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];
        
        translationMatrix = [
            [1, 0, 0, this.translate.x],
            [0, 1, 0, this.translate.y],
            [0, 0, 1, this.translate.z],
            [0, 0, 0, 1]
        ]
        
        scale(x, y, z) 
        {

        }
        
        rotate(roll, pitch, yaw)
        {

        }
        
        translate(x, y, z) 
        {

        }

        

        get matrix4x4() {
            return [
                [this.rotation[0][0], this.rotation[0][1], this.rotation[0][2], this.position.x],
                [this.rotation[1][0], this.rotation[1][1], this.rotation[1][2], this.position.y],
                [this.rotation[2][0], this.rotation[2][1], this.rotation[2][2], this.position.z],
                [       0,                      0,                  0,                 1    ]
            ];
        }

        get triangles() {
            let triangles = [
                //south
                [this.projVertices[0], this.projVertices[1], this.projVertices[2]],
                [this.projVertices[0], this.projVertices[2], this.projVertices[3]],
                //north
                [this.projVertices[7], this.projVertices[6], this.projVertices[5]],
                [this.projVertices[7], this.projVertices[5], this.projVertices[4]],
                //right
                [this.projVertices[3], this.projVertices[2], this.projVertices[6]],
                [this.projVertices[3], this.projVertices[6], this.projVertices[7]],
                //left
                [this.projVertices[4], this.projVertices[5], this.projVertices[1]],
                [this.projVertices[4], this.projVertices[1], this.projVertices[0]],
                //top
                [this.projVertices[1], this.projVertices[5], this.projVertices[6]],
                [this.projVertices[1], this.projVertices[6], this.projVertices[2]],
                //bottom
                [this.projVertices[3], this.projVertices[7], this.projVertices[4]],
                [this.projVertices[3], this.projVertices[4], this.projVertices[0]],
            ];

            return triangles;
        }

        transformVertices() {
            //Transform
            for (let i = 0; i < this.vertices.length; i++) {
                let p = this.vertices[i];

                // Rotate
                p = MatrixVectorMultiply(this.rotation, p);
                // Translate position
                p = VectorSum(p, this.position);

                //Project from world space to screen space (image space) 
                let depth = 1.0 / (3.0 - this.position.z);
                let perspProjMatrix = [
                    [depth, 0, 0],
                    [0, depth, 0],
                    [0, 0, 1]
                ];
                let projPoint = MatrixVectorMultiply(perspProjMatrix, p);
                projPoint = VectorScale(p, this.scale);

                // plot 2D
                strokeWeight(depth * 10);
                point(projPoint.x, projPoint.y);

                // update 
                this.projVertices[i] = projPoint;
            }
        }

        drawTriangles() {
            // Draw Triangles
            for (let t = 0; t < this.getTriangles().length; t++) {
                strokeWeight(2);
                let triPoints = this.getTriangles()[t];
                let p1 = triPoints[0];
                let p2 = triPoints[1];
                let p3 = triPoints[2];
                if (this.position.z < 3) {
                    line(p1.x, p1.y, 0, p2.x, p2.y, 0);
                    line(p2.x, p2.y, 0, p3.x, p3.y, 0);
                    line(p3.x, p3.y, 0, p1.x, p1.y, 0);
                }
            }
        }

        DrawMesh() {
            this.transformVertices();
            this.drawTriangles();
        }
    }








    let min = 340;
    let max = 640;
    let screenWidth = screen.width - 20;
    let screenHeight = screenWidth; //screen.height;// - 30;
   

    function setup() {
        createCanvas(screenWidth, screenWidth, WEBGL);
    }


    var cube = new CubeMesh();
    var angle = (Math.PI / 4) * 0.0005;
    var v = new Vec4();

    console.log(v2[0]);
    function draw() {
        background(0);
        rectMode(CENTER);
        stroke(255);
        strokeWeight(16);
        cube.scale = 100;
        //cube.position.x += 0.0050;
        //cube.position.y += 0.005;//250;//+= 0.01;
        //cube.position.z += 0.01;
            cube.rotation = MatrixMultiply(YPR(angle * ((screenWidth / 2) - mouseY), (angle + 0.000001) * -((screenWidth / 2) - mouseX), 0), cube.rotation);
        cube.DrawMesh();
    }















    //-----------WEB SOCKETS---------------

    var socket;
    function initWebSockets() {
        socket = new WebSocket('ws://' + window.location.hostname + ':81/');
        socket.onmessage = function (event) {
            incomingServerCommand(event);
        }
    }

    function incomingServerCommand(event) {
        console.log(event.data);
        var incoming = JSON.parse(event.data);
        console.log(incoming);

        // Convert R-hand to L-hand 
        imu.rotX = -(incoming.rotY);
        imu.rotY = -(incoming.rotZ);
        imu.rotZ = -(-incoming.rotX);

        // Map IMU rotation matrix to WebGL coordinate system
        let r1 = [0, 1, 0];
        let r2 = [0, 0, 1];
        let r3 = [-1, 0, 0];

        imu.i.x = (r1[0] * incoming.i_x + r1[1] * incoming.i_y + r1[2] * incoming.i_z);
        imu.i.y = (r2[0] * incoming.i_x + r2[1] * incoming.i_y + r2[2] * incoming.i_z);
        imu.i.z = (r3[0] * incoming.i_x + r3[1] * incoming.i_y + r3[2] * incoming.i_z);

        imu.j.x = (r1[0] * incoming.j_x + r1[1] * incoming.j_y + r1[2] * incoming.j_z);
        imu.j.y = (r2[0] * incoming.j_x + r2[1] * incoming.j_y + r2[2] * incoming.j_z);
        imu.j.z = (r3[0] * incoming.j_x + r3[1] * incoming.j_y + r3[2] * incoming.j_z);

        imu.k.x = (r1[0] * incoming.k_x + r1[1] * incoming.k_y + r1[2] * incoming.k_z);
        imu.k.y = (r2[0] * incoming.k_x + r2[1] * incoming.k_y + r2[2] * incoming.k_z);
        imu.k.z = (r3[0] * incoming.k_x + r3[1] * incoming.k_y + r3[2] * incoming.k_z);

        if (incoming.msg) {
            console.log(msg);
            //$("").html(incoming.msg);
        }
    }

    function sendServer(message = "") {
        //.socket.send('This data will be sent');
        var outgoing = {
            msg: message
        };
        socket.send(JSON.stringify(outgoing));
    }

    window.onload = function (event) {
        initWebSockets();
    }
</script>

</html>