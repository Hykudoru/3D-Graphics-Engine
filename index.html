<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.js"></script>-->
    <script src="jquery-3.6.4.min.js"></script>
    <script src="p5.min.js"></script>
    <script src="matrix.js"></script>
    <script src="graphics.js"></script>
    <title>3D Graphics</title>
    <style>
        body {
            background-color: #1b1a1a;
            color: rgb(213, 212, 212);
            text-align: center;
            margin: auto;
            padding: auto;
        }

        h1 {
            text-align: center;
        }
        table, th, td {
            border: 1px solid black;
            text-align: center;
        }
    </style>
</head>

<body>
    <!--
    <table id="local">
        <th>Local space</th>
        <tr>
            <th></th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
        </tr>
    </table>-->
    <h1 id="title">3D Graphics Engine</h1>
    <script src="sketch.js"></script>
    
</body>
<script>
    "use strict";
    let min = 340;
    let max = 640;


    var angle = (Math.PI / 4) * 0.0005;
   
    function setup() {
        createCanvas(screenWidth, screenHeight, WEBGL);
        var smallCube = new CubeMesh(1);
        var mediumCube = new CubeMesh(10, {x:0, y:0, z:-100});
        var largeCube = new CubeMesh(100, new Vec3(0,0,-300));
        camera.position.z = 0;
    }
    
    function draw() {
        background(0);
        rectMode(CENTER);
        stroke(255);
        strokeWeight(16);
        Mesh.meshes[1].rotation = MatrixMultiply(YPR(angle * ((screenWidth / 2)), angle * -((screenWidth / 2)), 0), Mesh.meshes[1].rotation);
        //cube2.rotation = MatrixMultiply(YPR(angle * ((screenWidth / 2) - mouseY), angle * -((screenWidth / 2) - mouseX), 0), cube2.rotation);

        Mesh.meshes.forEach(mesh => {
            mesh.DrawMesh();
        });
    }

    var moveSpeed = 3;
    window.onkeypress = function(e) {

        //----------Camera Controls-------
        let move = new Vec3();
        // console.log(e);
        if (e.key == 'w') {
            move = VectorScale(camera.forward, moveSpeed);
        }
        if (e.key == 's') {
            move = VectorScale(camera.back, moveSpeed);
        }
        if (e.key == 'a') {
            move = VectorScale(camera.left, moveSpeed);
        }
        if (e.key == 'd') {
            move = VectorScale(camera.right, moveSpeed);
        }

        if (e.key == ' ') {
            move = VectorScale(camera.up, moveSpeed);
        }
       
        camera.position = VectorSum(camera.position, move);

        if (e.key == 'q') {
            camera.rotation = MatrixMultiply(camera.rotation, RotZ(-PI/90));
        }
        else if (e.key == 'e') {
            camera.rotation = MatrixMultiply(camera.rotation, RotZ(PI/90));
        }

        // ---------------- FOV controls ------------------
        if (e.key == ".")
        {
            FOV(ToDeg(fov) + 5);
            console.log("FOV: "+ToDeg(fov));
        }
        if (e.key == ",")
        {
            FOV(ToDeg(fov) - 5);
            console.log("FOV: "+ToDeg(fov));
        }

        // Block Controls
        if (e.key == '8') {
            //cube.position = VectorSum(cube.position, up);
            cube.position = VectorSum(cube.position, up);
        }
        else if (e.key == '2') {
            //cube.position = VectorSum(cube.position, up);
            cube.position = VectorSum(cube.position, down);
        }
        else if (e.key == '4') {
            //cube.position = VectorSum(cube.position, up);
            cube.position = VectorSum(cube.position, left);
        }
        else if (e.key == '6') {
            //cube.position = VectorSum(cube.position, up);
            cube.position = VectorSum(cube.position, right);
        }
        
        
        //--------Spawn---------
        if (e.key === '`') {
            let c = new CubeMesh(1);
            c.position = VectorSum(camera.position, VectorScale(camera.forward, 10));
            console.log(c.position.ToString());
        }
    };

    let prevMouseX = 0;
    let prevMouseY = 0;
    let deltaMouseX = 0;
    let deltaMouseY = 0;

    onmousemove = function() {
        deltaMouseX = mouseX - prevMouseX;
        deltaMouseY = mouseY - prevMouseY;
        prevMouseX = mouseX;
        prevMouseY = mouseY;
        camera.rotation = MatrixMultiply(camera.rotation, YPR(0.008*deltaMouseY, .008 * -deltaMouseX, 0));
        let local = camera.localPosition;
        console.log(camera.back.ToString());

        console.log("Camera local pos:"+local.ToString());
        console.log("Camera pos:"+camera.position.ToString());
    };
</script>

</html>